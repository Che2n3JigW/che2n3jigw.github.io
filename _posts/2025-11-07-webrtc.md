---
categories: Android
title: Android WebRTC 开发
toc: true
toc_sticky: true
---

# 引言

##  WebRTC 简介

WebRTC（Web Real-Time Communication）是一个支持网页和移动端进行实时音视频通信的开源项目，由 Google 发起。它提供了 **点对点（Peer-to-Peer）音视频通话**、**数据通道传输** 等功能，无需额外插件即可在浏览器和移动应用中实现实时通信。

WebRTC 的核心组件包括：

- **MediaStream / MediaTrack**：捕获和管理本地音视频流。
- **PeerConnection**：实现点对点连接，负责音视频数据的传输和网络穿透。
- **DataChannel**：支持点对点的数据传输，可用于文件、消息或控制信息。
- **ICE / STUN / TURN**：实现 NAT 穿透和可靠的连接建立。

WebRTC 的特点：

- 低延迟实时通信（一般延迟在几十毫秒到几百毫秒）
- 开源免费，跨平台支持（Web、Android、iOS）
- 提供强大的加密和安全机制（SRTP、DTLS）

------

## Android 上使用 WebRTC 的优势

在 Android 平台上使用 WebRTC 开发音视频应用具有以下优势：

1. **跨平台兼容性**
    WebRTC 提供统一的 API，Android、iOS 和 Web 端可以实现互通。
2. **无需第三方插件**
    与传统的实时通信方案相比，WebRTC 不依赖外部 SDK 即可完成音视频通信，减少了依赖和安全风险。
3. **高性能与低延迟**
    Android WebRTC SDK 对音视频采集、编码、传输和渲染进行了优化，可实现流畅的实时通信体验。
4. **灵活的网络支持**
    内置 ICE、STUN、TURN 支持 NAT 穿透，能够在复杂网络环境下稳定连接。
5. **丰富的功能扩展性**
    支持多人通话（Mesh/SFU）、数据通道、屏幕共享、视频特效等高级功能，可满足各种业务需求。

------

## 文档目标与适用人群

**文档目标**：
 本指南旨在帮助开发者快速理解并掌握在 Android 平台上使用 WebRTC 开发实时音视频应用的流程，包括：

- 环境搭建与依赖管理
- 基础音视频通话实现
- 信令交互与网络处理

**适用人群**：

- **Android 开发工程师**：有一定 Android 开发基础，希望在应用中集成实时音视频功能。
- **RTC 技术爱好者**：想了解 WebRTC 原理及在移动端的实现方式。
- **产品/架构设计人员**：需要评估 WebRTC 在移动端应用中的可行性和优势。



# 基础概念

## PeerConnection

`PeerConnection` 是 WebRTC 的核心，用于在两个端点之间建立 **点对点（P2P）连接**，负责音视频数据和数据通道的传输。

**主要功能：**

- 管理本地和远程的音视频轨道（MediaStream/Track）
- 处理网络连接与 NAT 穿透（ICE、STUN、TURN）
- 发送和接收 SDP 信息（Offer/Answer）
- 支持数据通道（DataChannel）

## SDP（Session Description Protocol）

SDP 是 WebRTC 中用于 **描述媒体会话信息** 的协议，包括媒体格式、编解码器、网络参数等。

**主要作用：**

- 协商音视频编码格式
- 传递 ICE Candidate 信息
- 在 Offer/Answer 流程中交换连接信息

## ICE Candidate

ICE（Interactive Connectivity Establishment）用于 **帮助端点穿透 NAT/防火墙建立连接**。

**概念：**

- **Candidate**：候选网络地址（IP + 端口），可通过 STUN/TURN 获取
- 在 PeerConnection 中，ICE Candidate 会不断收集并发送给对端
- 对端收到 Candidate 后添加到自己的 PeerConnection

**理解**：统一 STUN 和 TURN，自动选择最佳连接路径，ICE 就是连接策略的“大脑”，让连接尽量 P2P，如果不行才走 TURN。

## STUN (Session Traversal Utilities for NAT)

- **作用**：帮助客户端获取自己在公网的 IP 和端口。
- **原理**：
  1. 客户端向 STUN 服务器发送请求
  2. STUN 服务器返回公网可访问的 IP:port
- **用途**：尽量使用 P2P 直连，减少中继服务器负载。

## TURN (Traversal Using Relays around NAT)

- **作用**：当 P2P 直连失败时，通过中继服务器转发流量。
- **特点**：
  - 可靠，但带宽成本高
  - 可以保证复杂 NAT 或防火墙环境下通信
- **注意**：通常部署在云服务器，需要足够带宽。



## 信令

信令（Signaling）是 **建立 WebRTC 连接的前置通信机制**，用于交换 SDP、ICE Candidate 等信息。

**特点：**

- WebRTC 本身不定义信令协议，开发者可自由选择实现方式
- 常用方式：WebSocket、HTTP、Socket.IO
- 信令流程一般包括：
  1. 客户端 A 发送 Offer 给信令服务器
  2. 服务器转发给客户端 B
  3. 客户端 B 回复 Answer
  4. 双方交换 ICE Candidate

## DataChannel

- WebRTC 不只是音视频，还可以传输任意二进制数据（文件、游戏数据等）
- 特性：
  - P2P 低延迟
  - 类似 TCP/UDP（可选可靠性）





# 搭建本地服务器环境

## AppRTC

- AppRTC 最初是由 Google（以及社区）推出的一个演示应用，用来展示 WebRTC 在浏览器之间进行实时音视频通信的能力。
- 仓库首页注明：该 demo 服务（例如 appr.tc ）已被关闭，推荐使用 Docker 部署自己的测试／开发实例.
- 它并不是一个完整商业级产品，而更多是一个“参考实现”或“起步模板”——你可以拿它来看、改、用作启动你的 WebRTC 应用。 
- 在 WebRTC 的 “参考应用（Reference Apps）”列表中，AppRTC 被列为一个浏览器间通话的示例。

### 拉取代码

```bash
git clone https://github.com/webrtc/apprtc.git
```

> 官方文档上docker部署的步骤是直接下载[Dockerfile](https://github.com/webrtc/apprtc/blob/master/Dockerfile#L72)文件，但是由于后续有部分自定义操作，所以个人推荐把源码个拉下来。

以下步骤Dockerfile文件中均有说明

### 构建 Docker 镜像

```bash
sudo docker build apprtc/
```

这条命令会把 `apprtc/` 目录里的 `Dockerfile` 用来生成一个可以运行 AppRTC 的容器镜像。

#### Dockerfile文件指令讲解

1. 基础镜像和环境准备

   ```dockerfile
   FROM golang:1.17.5-alpine3.15
   
   RUN apk add --no-cache git curl python2 build-base openssl-dev openssl 
   RUN git clone https://github.com/webrtc/apprtc.git
   ```

   - `FROM golang:1.17.5-alpine3.15`
     选择 Go 语言 + Alpine Linux 作为基础镜像，轻量、适合编译 Go 程序。

   - `apk add ...`
      安装依赖工具：`git`、`curl`、`python2`、编译工具 (`build-base`)、OpenSSL 库。

   - `git clone`
      克隆 AppRTC 的源码到镜像里。

2. 安装 Google App Engine (GAE) SDK

   ```dockerfile
   RUN curl https://dl.google.com/dl/cloudsdk/channels/rapid/downloads/google-cloud-sdk-367.0.0-linux-x86_64.tar.gz --output gcloud.tar.gz \
       && tar -xf gcloud.tar.gz \
       && google-cloud-sdk/bin/gcloud components install app-engine-python-extras app-engine-python cloud-datastore-emulator --quiet \
       && rm -f gcloud.tar.gz
   ```

   - 下载 Google Cloud SDK，用于运行 **GAE Python 应用**。

   - 安装必要组件：`app-engine-python-extras`、`app-engine-python`、`cloud-datastore-emulator`。

   - 清理安装包以减小镜像体积。

3. 构建 AppRTC GAE 应用

   ```dockerfile
   RUN python apprtc/build/build_app_engine_package.py apprtc/src/ apprtc/out/ \
       && curl https://webrtc.github.io/adapter/adapter-latest.js --output apprtc/src/web_app/js/adapter.js \
       && cp apprtc/src/web_app/js/*.js apprtc/out/js/
   ```

   - 运行 Python 脚本打包 AppRTC 的 GAE 应用到 `out/` 目录。

   - 下载最新的 WebRTC Adapter.js并复制到输出目录。

4. 创建启动脚本

   ```dockerfile
   RUN echo -e "#!/bin/sh\n" > /go/start.sh \
       && echo -e "`pwd`/google-cloud-sdk/bin/dev_appserver.py --host 0.0.0.0 `pwd`/apprtc/out/app.yaml &\n" >> /go/start.sh
   ```

   - 创建一个 `start.sh` 脚本，用来启动 **GAE 开发服务器** (`dev_appserver.py`) 并监听所有网络接口。

   - `&` 表示后台运行，这样可以同时启动其他服务。

5. 设置 Collider (WebRTC 信令服务器)

   ```dockerfile
   RUN export GOPATH=$HOME/goWorkspace/ \
       && go env -w GO111MODULE=off
   
   RUN ln -s `pwd`/apprtc/src/collider/collidermain $GOPATH/src \
       && ln -s `pwd`/apprtc/src/collider/collidertest $GOPATH/src \
       && ln -s `pwd`/apprtc/src/collider/collider $GOPATH/src \
       && cd $GOPATH/src \
       && go get collidermain \
       && go install collidermain
   
   # Add Collider executable to the start.sh bash script.
   RUN echo -e "$GOPATH/bin/collidermain -port=8089 -tls=true -room-server=http://localhost &\n" >> /go/start.sh
   ```

   - 设置 Go 工作空间 `GOPATH`，因为 Collider 是用 Go 写的。

   - 链接源代码并编译 `collidermain` 可执行文件。

   - 把 Collider 启动命令添加到 `start.sh`，监听 8089 端口并启用 TLS。

6. 安装并配置 stunnel (TLS/SSL 隧道)

   ```dockerfile
   RUN curl  https://www.stunnel.org/archive/5.x/stunnel-${STUNNEL_VERSION}.tar.gz --output stunnel.tar.gz\
       && tar -xf /usr/src/stunnel.tar.gz
   WORKDIR /usr/src/stunnel-${STUNNEL_VERSION}
   RUN ./configure --prefix=/usr && make && make install
   ```

   - 下载、编译 stunnel，用于将 HTTP 服务包装成 HTTPS（加密传输）。

   ```dockerfile
   RUN mkdir /cert
   RUN openssl req -x509 -out /cert/cert.crt -keyout /cert/key.pem \
     -newkey rsa:2048 -nodes -sha256 \
     -subj '/CN=localhost' -extensions EXT -config <( \
      printf "[dn]\nCN=localhost\n[req]\ndistinguished_name = dn\n[EXT]\nsubjectAltName=DNS:localhost\nkeyUsage=digitalSignature\nextendedKeyUsage=serverAuth") \
     && cat /cert/key.pem > /cert/cert.pem \
     && cat /cert/cert.crt >> /cert/cert.pem \
     && chmod 600 /cert/cert.pem /cert/key.pem /cert/cert.crt
     
   RUN echo -e "foreground=yes\n" > /usr/etc/stunnel/stunnel.conf \
       && echo -e "[AppRTC GAE]\n" >> /usr/etc/stunnel/stunnel.conf \ 
       && echo -e "accept=0.0.0.0:443\n" >> /usr/etc/stunnel/stunnel.conf \
       && echo -e "connect=0.0.0.0:8080\n" >> /usr/etc/stunnel/stunnel.conf \
       && echo -e "cert=/cert/cert.pem\n" >> /usr/etc/stunnel/stunnel.conf 
   
   RUN echo -e  "/usr/bin/stunnel &\n" >> /go/start.sh \
       && echo -e "wait -n\n" >> /go/start.sh \
       && echo -e "exit $?\n" >> /go/start.sh \
       && chmod +x /go/start.sh
   ```

   - 生成自签名证书用于 TLS。
   - 配置 stunnel，将外部 HTTPS 请求转发到本地的 HTTP 服务（端口 8080）。
   - 将 stunnel 启动命令加入 `start.sh`

7. 最终启动命令

   ```dockerfile
   CMD /go/start.sh
   ```

   - 运行 `start.sh`
     1. AppRTC GAE 应用
     2. Collider 信令服务器
     3. stunnel TLS 隧道

### 运行 Docker 镜像

1. 查询刚刚创建好的镜像

   ```bash
   sudo docker images
   ```
    {% 
    include figure popup=true image_path="/assets/images/android/webrtc/query_images.png" 
    %}

   记录IMAGE ID : **2546b3f6f972**

2. 运行 Docker 镜像

   ```bash
   sudo docker run -p 443:443 -p 8089:8089 --rm -ti 2546b3f6f972
   ```

   |                | 说明                                                         |
   | -------------- | ------------------------------------------------------------ |
   | `docker run`   | 创建并运行一个新的容器                                       |
   | `-p 443:443`   | 把 **主机的 443 端口** 映射到 **容器的 443 端口**（容器内 stunnel 的 HTTPS 服务） |
   | `-p 8089:8089` | 把 **主机的 8089 端口** 映射到 **容器的 8089 端口**（容器内 Collider 信令服务） |
   | `--rm`         | 容器退出后自动删除，不保留残留数据                           |
   | `-ti`          | 分配伪终端并启用交互模式（`-t` 分配 TTY，`-i` 保持输入）     |
   | `503621f4f7bd` | 镜像 ID                                                      |



### 进入AppRTC 测试页面

> https://localhost/?wshpp=localhost:8089&wstls=true

{% 
include figure popup=true image_path="/assets/images/android/webrtc/show_local_web.png" 
%}

#### 局域网访问

1. 查询当前IP

   ```bash
   ip a
   ```

   找到主机ip

2. 使用IP替换localhost(假设ip为172.22.193.168)

   https://172.22.193.168/?wshpp=172.22.193.168:8089&wstls=true

   Request host is not whitelist enabled for this server. Please use the --host command-line flag to whitelist a specific host (recommended) or use --enable_host_checking to disable host checking. See the command-line flags help text for more information. 

   > **dev_appserver.py 默认会检查 Host 白名单**，如果你的请求不是来自默认允许的 localhost / 127.0.0.1 就会出现该错误。

   **解决方案：**

   1. 打开Dockerfile文件
   
   2. 找到dev_appserver.py, 并添加参数（enable_host_checking=false）关闭 Host 检查
   
      ```bash
      RUN echo -e "#!/bin/sh\n" > /go/start.sh \
          && echo -e "`pwd`/google-cloud-sdk/bin/dev_appserver.py --host 0.0.0.0 --enable_host_checking=false `pwd`/apprtc/out/app.yaml &\n" >> /go/start.sh
      ```
   
   3. 重启构建并运行镜像
   
      ```bash
      # 构建
      sudo docker build apprtc/
      # 查询镜像
      sudo docker images
      # 运行镜像
      sudo docker run -p 443:443 -p 8089:8089 --rm -ti <镜像ID>
      ```
   
   4. 再次访问https://172.22.193.168/?wshpp=172.22.193.168:8089&wstls=true
   
{% 
include figure popup=true image_path="/assets/images/android/webrtc/show_ip_web.png" 
%}



### 进入房间

点击JOIN进入房间页面，由于电脑没有摄像头，这里使用手机测试。

{% 
include figure popup=true image_path="/assets/images/android/webrtc/show_join_room_turn_error.jpg" 
%}

在浏览器打印错误信息
Access to XMLHttpRequest at 'https://appr.tc/v1alpha/iceconfig?key=' from origin 'https://172.22.193.168' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.
POST https://appr.tc/v1alpha/iceconfig?key= net::ERR_FAILED 405 (Method Not Allowed)

> ICE 服务器请求失败，https://appr.tc/v1alpha/iceconfig?key=产生的跨域问题。

解决方案: 自建 TURN/STUN 服务器，下面说明



## Coturn（TURN/STUN 服务器）

Coturn 是最常用的开源 TURN/STUN 服务器。

### 安装

```bash
sudo apt update
sudo apt install coturn -y
```

### 配置 Coturn

编辑配置文件：

```
sudo nano /etc/turnserver.conf
```

最基本配置：

```bash
# 监听端口
listening-port=3478

# 监听所有网卡
listening-ip=0.0.0.0
relay-ip=0.0.0.0

# 允许 UDP/TCP
protocols=udp,tcp

# 指定公网 IP 或局域网 IP（你虚拟机的 IP）
# 如果只是局域网测试，可以留空
# external-ip=<你的主机公网IP>

# 用户认证
lt-cred-mech
user=turnuser:turnpassword

# 启用日志
verbose

# 启动 STUN
stun-only
```

如果你只想做 **STUN** 测试，可以加 `stun-only`。
如果希望支持 TURN（中继流量），去掉 `stun-only`。

### 启动 Coturn

临时启动（命令行方式）：

```bash
sudo turnserver -c /etc/turnserver.conf
```

验证是否在监听 3478 端口：

```bash
sudo netstat -tulnp | grep 3478
```

### 配置ICE_SERVER

打开apprtc/src/app_engine/constants.py

修改ICE_SERVER_OVERRIDE参数

```python
ICE_SERVER_OVERRIDE = [
  {
    "urls": [
      "stun:172.22.193.168:3478"
    ]
  },
  {
    "urls": [
      "turn:172.22.193.168:3478?transport=udp",
      "turn:172.22.193.168:3478?transport=tcp"
    ],
    "username": "turnuser",
    "credential": "turnpassword"
  }
]
```

修改Dockerfile

```dockerfile
RUN git clone https://github.com/webrtc/apprtc.git

# git clone 后（或直接用本地源码），覆盖 constants.py
COPY src/app_engine/constants.py apprtc/src/app_engine/constants.py  


# localhost替换成IP
RUN openssl req -x509 -out /cert/cert.crt -keyout /cert/key.pem \
  -newkey rsa:2048 -nodes -sha256 \
  -subj '/CN=172.22.193.168' -extensions EXT -config <( \
   printf "[dn]\nCN=172.22.193.168\n[req]\ndistinguished_name = dn\n[EXT]\nsubjectAltName=IP:172.22.193.168\nkeyUsage=digitalSignature\nextendedKeyUsage=serverAuth") \
  && cat /cert/key.pem > /cert/cert.pem \
  && cat /cert/cert.crt >> /cert/cert.pem \
  && chmod 600 /cert/cert.pem /cert/key.pem /cert/cert.crt
```

重启构建并运行镜像

```bash
# 构建
sudo docker build apprtc/
# 查询镜像
sudo docker images
# 运行镜像
sudo docker run -p 443:443 -p 8089:8089 --rm -ti <镜像ID>
```

## 测试成果

两个Android手机打开浏览器进入https://172.22.193.168/?wshpp=172.22.193.168:8089&wstls=true，输入相同的ROOM ID.

{% 
include figure popup=true image_path="/assets/images/android/webrtc/show_finish.jpg" 
%}
